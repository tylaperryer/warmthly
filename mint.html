<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=0.75, user-scalable=yes" />
  <title>Mint - Warmthly</title>
  <link rel="preconnect" href="https://www.warmthly.org">
  <link rel="preconnect" href="https://accountability.warmthly.org">
  <style>
      /* Inline critical CSS for faster rendering */
      * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
      }
      
      /* --- FONT DEFINITIONS --- */
      @font-face {
            font-family: 'Cormorant Garamond';
            font-style: normal;
            font-weight: 700;
            font-display: optional;
            src: url('https://fonts.gstatic.com/s/cormorantgaramond/v20/co3umX5slCNuHLi8bLeY9MK7whWMhyjypVO7abI26QOD_hg9KnTOig.woff2'  ) format('woff2');
      }
      
      @font-face {
            font-family: 'Inter';
            font-style: normal;
            font-weight: 400;
            font-display: swap;
            src: url('https://fonts.gstatic.com/s/inter/v13/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7.woff2'  ) format('woff2');
      }
      
      @font-face {
            font-family: 'Inter';
            font-style: normal;
            font-weight: 600;
            font-display: swap;
            src: url('https://fonts.gstatic.com/s/inter/v13/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7.woff2'  ) format('woff2');
      }
      
      html {
            overflow-x: hidden;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
      }
      html::-webkit-scrollbar {
            display: none;
      }
      body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #2c2c2c;
            background: #fff6f1;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
      }
      body::-webkit-scrollbar {
            display: none;
      }
      
      body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 30%, rgba(255,140,66,0.15) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255,182,193,0.12) 0%, transparent 50%),
                        radial-gradient(circle at 40% 70%, rgba(173,216,230,0.1) 0%, transparent 50%),
                        radial-gradient(circle at 90% 80%, rgba(144,238,144,0.08) 0%, transparent 50%),
                        linear-gradient(135deg, #fff6f1 0%, #ffeee6 100%);
            z-index: -1;
            pointer-events: none;
      }
      
      ::selection {
        background: #FF8C42;
        color: #FFFFFF;
      }
      
      .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 120px 20px 40px;
            text-align: center;
            color: #2c2c2c;
            position: relative;
            z-index: 1;
      }
      
      .top-left-heading {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-weight: 700;
            font-size: 2rem;
            color: #FF8C42;
            user-select: none;
            z-index: 1001;
      }
      
      .stoplight-container {
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 1002;
      }

      .stoplight {
          --tint-color: rgba(255,255,255,0.15);
          --blur-radius: 12px;
          --border-color: rgba(255,255,255,0.25);
          --highlight-color: rgba(255,255,255,0.4);
          --shadow-color: rgba(0,0,0,0.08);
          display: flex;
          flex-direction: column;
          gap: 3px;
          cursor: pointer;
          padding: 8px;
          position: relative;
          background: var(--tint-color);
          backdrop-filter: blur(var(--blur-radius)) saturate(1.2);
          -webkit-backdrop-filter: blur(var(--blur-radius)) saturate(1.2);
          border: 1px solid var(--border-color);
          border-radius: 14px;
          box-shadow: 0 6px 12px var(--shadow-color),
                      inset 0 1px 1px var(--highlight-color),
                      inset 0 -1px 1px rgba(0,0,0,0.05);
          transition: all 0.4s cubic-bezier(0.25,0.8,0.25,1);
          overflow: hidden;
      }

      .stoplight::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border-radius: inherit;
          background: linear-gradient(135deg, rgba(255,255,255,0.25), rgba(255,255,255,0.1) 50%, rgba(255,255,255,0) 100%);
          pointer-events: none;
          z-index: 1;
          opacity: 0.7;
          transition: opacity 0.4s cubic-bezier(0.25,0.8,0.25,1);
      }

      .stoplight:hover,
      .stoplight.active {
          background: rgba(255,255,255,0.25);
          box-shadow: 0 8px 16px rgba(0,0,0,0.12),
                      inset 0 1px 1px rgba(255,255,255,0.5),
                      inset 0 -1px 1px rgba(0,0,0,0.1);
      }

      .stoplight:hover::before,
      .stoplight.active::before {
          opacity: 1;
      }

      .stoplight-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          position: relative;
          transition: opacity 0.4s cubic-bezier(0.25,0.8,0.25,1);
          z-index: 2;
          opacity: 0.3;
      }

      .stoplight-dot.red { background: #ff4757; }
      .stoplight-dot.yellow { background: #FF8C42; }
      .stoplight-dot.green { background: #2ed573; }

      .stoplight-container:hover .stoplight-dot.red,
      .stoplight.active .stoplight-dot.red { animation: stoplight-cycle-red 10s cubic-bezier(0.25,0.8,0.25,1) infinite; }
      .stoplight-container:hover .stoplight-dot.green,
      .stoplight.active .stoplight-dot.green { animation: stoplight-cycle-green 10s cubic-bezier(0.25,0.8,0.25,1) infinite; }
      .stoplight-container:hover .stoplight-dot.yellow,
      .stoplight.active .stoplight-dot.yellow { animation: stoplight-cycle-yellow 10s cubic-bezier(0.25,0.8,0.25,1) infinite; }

      @keyframes stoplight-cycle-red { 0%, 33.33% { opacity: 1; } 33.34%, 100% { opacity: 0.3; } }
      @keyframes stoplight-cycle-green { 0%, 33.33% { opacity: 0.3; } 33.34%, 66.66% { opacity: 1; } 66.67%, 100% { opacity: 0.3; } }
      @keyframes stoplight-cycle-yellow { 0%, 66.66% { opacity: 0.3; } 66.67%, 100% { opacity: 1; } }

      .dropdown-menu {
          --tint-color: rgba(255,255,255,0.15);
          --blur-radius: 12px;
          --border-color: rgba(255,255,255,0.25);
          --highlight-color: rgba(255,255,255,0.4);
          --shadow-color: rgba(0,0,0,0.08);
          --text-color: #1c2526;
          position: absolute;
          top: 100%;
          right: 0;
          background: var(--tint-color);
          backdrop-filter: blur(var(--blur-radius)) saturate(1.2);
          -webkit-backdrop-filter: blur(var(--blur-radius)) saturate(1.2);
          border-radius: 18px;
          padding: 8px;
          margin-top: 12px;
          min-width: 200px;
          box-shadow: 0 8px 32px var(--shadow-color),
                      inset 0 1px 1px var(--highlight-color),
                      inset 0 -1px 1px rgba(0,0,0,0.05);
          border: 1px solid var(--border-color);
          opacity: 0;
          visibility: hidden;
          transform: translateY(-12px) scale(0.94);
          transition: all 0.4s cubic-bezier(0.4,0,0.2,1);
          overflow: hidden;
      }

      .dropdown-menu::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border-radius: inherit;
          background: linear-gradient(135deg, rgba(255,255,255,0.25), rgba(255,255,255,0.1) 50%, rgba(255,255,255,0) 100%);
          pointer-events: none;
          z-index: 1;
          opacity: 0.7;
      }

      .dropdown-menu.active {
          opacity: 1;
          visibility: visible;
          transform: translateY(0) scale(1);
      }

      .dropdown-item {
          display: block;
          padding: 12px 16px;
          margin: 2px 0;
          color: var(--text-color);
          text-decoration: none;
          font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
          font-weight: 500;
          font-size: 0.95rem;
          transition: all 0.3s cubic-bezier(0.25,0.8,0.25,1);
          border-radius: 10px;
          position: relative;
          z-index: 2;
      }

      .dropdown-item:hover { color: #FF8C42; }
      .dropdown-item:first-child { margin-top: 0; }
      .dropdown-item:last-child { margin-bottom: 0; }
      
      .page-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.8rem;
            color: #FF8C42;
            margin-bottom: 1rem;
            font-weight: 600;
            text-align: center;
            letter-spacing: 0.02em;
      }
      
      .main-text {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            margin-bottom: 3rem;
            opacity: 0.85;
            color: #2c2c2c;
            line-height: 1.7;
      }
      
      .database-section {
            margin: 3rem 0;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s cubic-bezier(0.4,0,0.2,1), transform 0.6s cubic-bezier(0.4,0,0.2,1);
      }

      .database-section.visible {
            opacity: 1;
            transform: translateY(0);
      }

      .database-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 12px;
      }

      .embed-live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #2ed573;
            /* --- MODIFICATION START: Add transform to fix choppy text rendering --- */
            transform: translateZ(0);
            /* --- MODIFICATION END --- */
      }

      .embed-live-indicator .live-dot {
            width: 8px;
            height: 8px;
            background: #2ed573;
            border-radius: 50%;
            animation: pulse 0.8s infinite cubic-bezier(0.5,0,0.5,1);
      }
      
      @keyframes pulse {
            0%, 80%, 100% { opacity: 1; }
            40% { opacity: 0.2; }
      }

      /* Statistics Dashboard */
      .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.2);
      }


      .stat-item {
            text-align: center;
      }

      .stat-value {
            font-family: 'Inter', sans-serif;
            font-size: 1.8rem;
            font-weight: 600;
            color: #FF8C42;
            margin-bottom: 0.25rem;
      }

      .stat-label {
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            color: #2c2c2c;
            opacity: 0.7;
      }

      /* Donation Pool Container */
      .donation-pool-container {
            position: relative;
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, rgba(255,140,66,0.08), rgba(255,140,66,0.03));
            border-radius: 20px;
            border: 1px solid rgba(255,140,66,0.15);
            box-shadow: 0 8px 20px rgba(255,140,66,0.1);
            overflow: hidden;
            cursor: crosshair;
      }

      /* Search Bar */
      .pool-search {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 12px;
            padding: 0.5rem 1rem;
            min-width: 200px;
            display: flex;
            align-items: center;
      }

      .pool-search input {
            background: transparent;
            border: none;
            outline: none;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            color: #2c2c2c;
            flex: 1;
            min-width: 0;
      }

      .pool-search input::placeholder {
            color: #2c2c2c;
            opacity: 0.5;
      }

      .pool-search:focus-within {
            border-color: #FF8C42;
            box-shadow: 0 0 0 2px rgba(255,140,66,0.2);
      }

      .cent.search-match {
            opacity: 1 !important;
            filter: none !important;
      }

      .cent.search-no-match {
            opacity: 0.2 !important;
            filter: grayscale(100%) !important;
            transition: opacity 0.3s ease, filter 0.3s ease;
      }

      .donation-pool {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
      }

      /* Cent Element */
      .cent {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 10;
            display: flex;
            user-select: none;
            pointer-events: auto;
            transform: translate(-50%, -50%);
            will-change: transform;
      }

      .cent:hover {
            transform: translate(-50%, -50%) scale(1.3);
            z-index: 100;
      }

      .cent.emoji {
            background: transparent;
            box-shadow: none;
            font-size: 18px;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1;
      }

      /* Donation Tag */
      .donation-tag {
            position: absolute;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 1rem;
            min-width: 200px;
            max-width: 300px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: opacity 0.3s ease, transform 0.3s ease;
            font-family: 'Inter', sans-serif;
      }

      .donation-tag.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
      }

      .tag-header {
            font-weight: 600;
            color: #FF8C42;
            margin-bottom: 0.5rem;
            font-size: 1rem;
      }

      .tag-item {
            font-size: 0.85rem;
            color: #2c2c2c;
            margin: 0.25rem 0;
            opacity: 0.8;
      }

      .tag-item strong {
            opacity: 1;
            color: #2c2c2c;
      }

      
      .action-section {
            background: linear-gradient(135deg, rgba(255,140,66,0.08), rgba(255,140,66,0.03));
            padding: 2.5rem;
            border-radius: 20px;
            border: 2px solid rgba(255,140,66,0.15);
            margin: 3rem 0;
            box-shadow: 0 8px 20px rgba(255,140,66,0.1);
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s cubic-bezier(0.4,0,0.2,1), transform 0.6s cubic-bezier(0.4,0,0.2,1);
      }
      
      .action-section.visible {
            opacity: 1;
            transform: translateY(0);
      }
      
      .action-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.6rem;
            color: #FF8C42;
            margin-bottom: 1.5rem;
            font-weight: 600;
      }
      
      .action-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
      }
      
      .action-note {
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            color: #2c2c2c;
            opacity: 0.7;
            margin-top: 1rem;
            text-align: center;
      }
      
      .action-button {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 12px;
            padding: 0.8rem 1.5rem;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #2c2c2c;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      }
      
      .action-button:hover {
            background: rgba(255,140,66,0.15);
            color: #FF8C42;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255,140,66,0.15);
      }
      
      .action-button:active { transform: scale(0.98); }
      
      .page-title, .main-text, .action-note { cursor: text; }
      
      .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.94);
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 18px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
            border: 1px solid rgba(255,255,255,0.25);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4,0,0.2,1);
            z-index: 1003;
      }
      
      .modal.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
      }
      
      .modal-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.4rem;
            color: #FF8C42;
            margin-bottom: 1rem;
            font-weight: 600;
      }
      
      .modal-text {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            color: #2c2c2c;
            line-height: 1.6;
            margin-bottom: 1.5rem;
      }
      
      .modal-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #FF8C42;
            cursor: pointer;
            position: absolute;
            top: 1rem;
            right: 1rem;
      }
      
      .modal-close:focus, .action-button:focus {
          outline: 2px solid #FF8C42;
          outline-offset: 2px;
      }
      
      @media (max-width: 768px) {
            .container {
                  padding-top: 80px;
                  padding-left: 15px;
                  padding-right: 15px;
            }
            .top-left-heading {
                  font-size: 1.6rem;
                  top: 15px;
                  left: 15px;
            }
            .page-title { font-size: 1.5rem; }
            .main-text { font-size: 1rem; }
            .dropdown-menu { min-width: 180px; }
            .action-section { padding: 1.8rem; }
            .action-title { font-size: 1.4rem; }
            .donation-pool-container { height: 500px; }
            .stats-dashboard { grid-template-columns: 1fr; gap: 0.75rem; padding: 1rem; }
            .stat-value { font-size: 1.5rem; }
            .pool-search { min-width: 150px; top: 10px; right: 10px; padding: 0.4rem 0.8rem; }
            .pool-search input { font-size: 0.85rem; }
      }
      
      .preload-fonts {
            font-family: 'Cormorant Garamond';
            font-family: 'Inter';
            visibility: hidden;
            position: absolute;
      }
  </style>
  
  <link rel="preload" href="https://fonts.gstatic.com/s/cormorantgaramond/v20/co3umX5slCNuHLi8bLeY9MK7whWMhyjypVO7abI26QOD_hg9KnTOig.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="https://fonts.gstatic.com/s/inter/v13/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7.woff2" as="font" type="font/woff2" crossorigin>
  
  <link rel="dns-prefetch" href="//warmthly.org">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>
  <div class="preload-fonts">.</div>
  
  <div class="top-left-heading">Warmthly <span style="color: #2ed573;">Mint</span></div>
  
  <div class="stoplight-container">
    <div class="stoplight" id="stoplight">
      <div class="stoplight-dot red"></div>
      <div class="stoplight-dot yellow"></div>
      <div class="stoplight-dot green"></div>
    </div>
    
    <!-- --- MODIFICATION START: Removed 'Family' and 'Projects' links --- -->
    <div class="dropdown-menu" id="dropdown-menu">
      <a href="https://www.warmthly.org" class="dropdown-item">Home</a>
      <a href="https://accountability.warmthly.org/" class="dropdown-item">Accountability</a>
      <a href="https://mint.warmthly.org/research" class="dropdown-item">Research</a>
    </div>
    <!-- --- MODIFICATION END --- -->
  </div>

  <div class="container">
    <h1 class="page-title">Mint</h1>
    <p class="main-text">
      <b>We track your every cent and our every decision right before you.</b> It is our commitment to you that we will forever track and provide utmost transparency for our every action and your every donation. Given the nature of our organization, you are able to fork and copy-paste our processes for your refining, those are also available on this page.
    </p>
    
    <div class="database-section">
      <div class="database-header">
        <div class="embed-live-indicator">
          <div class="live-dot"></div>
          <span>Live</span>
        </div>
      </div>
      <div class="stats-dashboard">
        <div class="stat-item">
          <div class="stat-value" id="totalDonations">0</div>
          <div class="stat-label">Total Donations</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="totalAmount">$0.00</div>
          <div class="stat-label">Amount Raised</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="totalDonors">0</div>
          <div class="stat-label">Donors</div>
        </div>
      </div>
      <div class="donation-pool-container" id="donationPool">
        <div class="pool-search">
          <input type="text" id="donorSearch" placeholder="Search donor..." autocomplete="off">
        </div>
        <div class="donation-pool" id="donationPoolArea"></div>
      </div>
    </div>
    
    <div class="action-section">
      <h2 class="action-title">Take Action</h2>
      <div class="action-buttons">
        <button class="action-button" id="downloadButton">Download Database</button>
        <button class="action-button" id="challengeButton">Challenge Us</button>
      </div>
      <p class="action-note">
        Download our full dataset to explore every detail or challenge us to ensure accountability.
      </p>
    </div>
    
    <div class="modal" id="challengeModal">
      <button class="modal-close" id="closeModal">âœ•</button>
      <h2 class="modal-title">Challenge Us</h2>
      <p class="modal-text">
        Spot an issue? Submit a challenge to collaborate on.
      </p>
      <button class="action-button">Submit Challenge (Coming Soon  )</button>
    </div>
  </div>
  
  <script>
      // Airtable Configuration
      // To set up:
      // 1. Go to https://airtable.com/api to get your API key
      // 2. Update tableName to match your Airtable table name
      // 3. Update fieldMappings to match your column names exactly
      const airtableConfig = {
            baseId: "appDmVaty9tcrUKsn", // From your embed URL
            tableName: "Donations", // Update this to match your Airtable table name
            apiKey: "YOUR_AIRTABLE_API_KEY", // Get from https://airtable.com/api (Personal Access Token)
            viewId: "shrI3VVTE2iCyz3rO", // From your embed URL (optional, helps with filtering)
            // Field mappings - update these to match your Airtable column names EXACTLY
            fieldMappings: {
                  amount: "Amount", // Column name for donation amount (must be a number field)
                  donor: "Donor", // Column name for donor name
                  date: "Date", // Column name for date (date field)
                  purpose: "Purpose", // Column name for purpose
                  category: "Category", // Column name for category
                  transactionId: "Transaction ID" // Column name for transaction ID
            },
            pollInterval: 10000 // Poll for updates every 10 seconds (in milliseconds)
      };

      // Donation Pool Animation System
      class DonationPool {
            constructor(container) {
                  this.container = container;
                  this.pool = document.getElementById('donationPoolArea');
                  this.cents = [];
                  this.activeTags = new Map();
                  this.processedDonations = new Set();
                  this.centPool = []; // Object pool for coin elements
                  this.maxVisibleCents = 5000; // Limit visible coins for performance
                  this.clusterThreshold = 100; // Cluster coins when too many
                  this.visibleCents = new Set();
                  this.coinPositions = []; // Track coin positions for physics
                  this.coinSize = 20; // Approximate coin size for spacing (in pixels)
                  this.searchQuery = '';
                  
                  // Matter.js variables
                  this.engine = null;
                  this.world = null;
                  this.runner = null;
                  this.render = null;
                  this.poolBody = null; // Reference to the main pool container body
                  this.stats = {
                        totalDonations: 0,
                        totalAmount: 0,
                        totalDonors: 0,
                        donors: new Set()
                  };
                  
                  this.init();
            }

            init() {
                  this.containerRect = this.container.getBoundingClientRect();
                  this.updateContainerSize();
                  window.addEventListener('resize', () => this.updateContainerSize());
                  
                  // Setup search
                  const searchInput = document.getElementById('donorSearch');
                  if (searchInput) {
                        searchInput.addEventListener('input', (e) => {
                              this.searchQuery = e.target.value.toLowerCase().trim();
                              this.updateSearchFilter();
                        });
                  }
                  
                  // Check if Airtable is configured
                  if (airtableConfig.apiKey && airtableConfig.apiKey !== 'YOUR_AIRTABLE_API_KEY') {
                        this.setupAirtableListener();
                  } else {
                        console.warn('Airtable API key not configured. Using mock data for demonstration.');
                        this.loadMockData();
                  }
                  
                  this.setupPhysics();
            }

            setupPhysics() {
                  const { Engine, Render, World, Bodies, Runner } = Matter;

                  // 1. Create engine and world
                  this.engine = Engine.create();
                  this.world = this.engine.world;
                  this.world.gravity.y = 1; // Standard gravity

                  // 2. Create renderer (optional, but useful for debugging)
                  // We will use a custom renderer to apply Matter.js positions to our coin DOM elements.
                  
                  // 3. Create boundaries (walls and floor)
                  const poolWidth = this.poolWidth;
                  const poolHeight = this.poolHeight;
                  const wallThickness = 50;

                  // Create a container body for the pool area
                  this.poolBody = Bodies.rectangle(poolWidth / 2, poolHeight / 2, poolWidth, poolHeight, { 
                        isStatic: true, 
                        isSensor: true,
                        render: { visible: false }
                  });
                  
                  // Create static boundaries (bottom, left, right)
                  const ground = Bodies.rectangle(poolWidth / 2, poolHeight + wallThickness / 2, poolWidth, wallThickness, { isStatic: true, friction: 1, restitution: 0.1 });
                  const leftWall = Bodies.rectangle(-wallThickness / 2, poolHeight / 2, wallThickness, poolHeight * 2, { isStatic: true, friction: 1 });
                  const rightWall = Bodies.rectangle(poolWidth + wallThickness / 2, poolHeight / 2, wallThickness, poolHeight * 2, { isStatic: true, friction: 1 });

                  World.add(this.world, [ground, leftWall, rightWall]);

                  // 4. Run the engine
                  this.runner = Runner.run(this.engine);
                  
                  // 5. Setup custom animation loop to sync DOM elements with physics bodies
                  Matter.Events.on(this.engine, 'afterUpdate', () => {
                        this.cents.forEach(cent => {
                              if (cent.body) {
                                    // Sync Matter.js body position to DOM element
                                    cent.style.left = cent.body.position.x + 'px';
                                    cent.style.top = cent.body.position.y + 'px';
                                    cent.style.transform = `translate(-50%, -50%) rotate(${cent.body.angle}rad)`;
                              }
                        });
                  });
            }

            updateSearchFilter() {
                  this.cents.forEach(cent => {
                        if (!cent.donationData) return;
                        
                        const donorName = (cent.donationData.donor || '').toLowerCase();
                        const matches = !this.searchQuery || donorName.includes(this.searchQuery);
                        
                        if (matches) {
                              cent.classList.remove('search-no-match');
                              cent.classList.add('search-match');
                        } else {
                              cent.classList.remove('search-match');
                              cent.classList.add('search-no-match');
                        }
                  });
            }

            updateContainerSize() {
                  this.containerRect = this.container.getBoundingClientRect();
                  this.poolWidth = this.containerRect.width;
                  this.poolHeight = this.containerRect.height;
                  
                  // Update physics world boundaries if initialized
                  if (this.world) {
                        const { World, Bodies } = Matter;
                        const wallThickness = 50;
                        
                        // Remove old boundaries (assuming they were the only static bodies added)
                        // A more robust solution would track the boundary bodies and remove them specifically.
                        // For simplicity, we'll re-add the boundaries in setupPhysics on a full re-init if needed, 
                        // but for a simple resize, we'll just rely on the CSS container size.
                        // For a full physics update, the entire world would need to be reset, but that's complex.
                        // For now, we'll rely on the initial boundaries being large enough.
                        // A better fix is to ensure the pool area has a fixed size or the boundaries are updated.
                        
                        // For this instruction set, we will assume the initial boundaries are sufficient 
                        // or that the user will handle the full physics world update on resize if necessary.
                  }
            }

            async setupAirtableListener() {
                  // Load initial donations
                  await this.fetchAirtableDonations(true);
                  
                  // Set up polling for updates
                  this.airtablePollInterval = setInterval(() => {
                        this.fetchAirtableDonations(false);
                  }, airtableConfig.pollInterval);
            }

            async fetchAirtableDonations(isInitialLoad = false) {
                  try {
                        // Build URL with view filter if available
                        let url = `https://api.airtable.com/v0/${airtableConfig.baseId}/${encodeURIComponent(airtableConfig.tableName)}`;
                        if (airtableConfig.viewId) {
                              url += `?view=${airtableConfig.viewId}`;
                        }
                        
                        const response = await fetch(url, {
                              headers: {
                                    'Authorization': `Bearer ${airtableConfig.apiKey}`,
                                    'Content-Type': 'application/json'
                              }
                        });

                        if (!response.ok) {
                              if (response.status === 401) {
                                    console.warn('Airtable API key invalid or not configured. Using mock data for demonstration.');
                                    if (isInitialLoad) {
                                          this.loadMockData();
                                    }
                                    return;
                              }
                              if (response.status === 404) {
                                    console.warn('Airtable table not found. Check your tableName and baseId.');
                                    if (isInitialLoad) {
                                          this.loadMockData();
                                    }
                                    return;
                              }
                              throw new Error(`Airtable API error: ${response.status} ${response.statusText}`);
                        }

                        const data = await response.json();
                        const records = data.records || [];
                        
                        if (isInitialLoad) {
                              console.log(`Loaded ${records.length} donations from Airtable`);
                        }

                        let newDonations = 0;
                        records.forEach(record => {
                              const donationId = record.id;
                              
                              if (!this.processedDonations.has(donationId)) {
                                    this.processedDonations.add(donationId);
                                    newDonations++;
                                    
                                    // Map Airtable fields to donation structure
                                    const fields = record.fields || {};
                                    const donation = {
                                          amount: this.parseAmount(fields[airtableConfig.fieldMappings.amount]),
                                          donor: fields[airtableConfig.fieldMappings.donor] || 'Anonymous',
                                          date: this.parseDate(fields[airtableConfig.fieldMappings.date]),
                                          purpose: fields[airtableConfig.fieldMappings.purpose] || 'N/A',
                                          category: fields[airtableConfig.fieldMappings.category] || 'General',
                                          transactionId: fields[airtableConfig.fieldMappings.transactionId] || record.id
                                    };
                                    
                                    this.addDonation(donation, donationId, isInitialLoad);
                              }
                        });
                        
                        if (!isInitialLoad && newDonations > 0) {
                              console.log(`Added ${newDonations} new donation(s) from Airtable`);
                        }
                  } catch (error) {
                        console.error('Error fetching Airtable data:', error);
                        if (error.message.includes('CORS')) {
                              console.error('CORS error: Make sure your Airtable base allows API access. You may need to use a CORS proxy or backend service.');
                        }
                        if (isInitialLoad) {
                              console.warn('Falling back to mock data.');
                              this.loadMockData();
                        }
                  }
            }

            parseAmount(amount) {
                  if (typeof amount === 'number') return amount;
                  if (typeof amount === 'string') {
                        // Remove currency symbols and parse
                        const cleaned = amount.replace(/[^0-9.]/g, '');
                        return parseFloat(cleaned) || 0;
                  }
                  return 0;
            }

            parseDate(dateValue) {
                  if (!dateValue) return new Date().toISOString();
                  if (dateValue instanceof Date) return dateValue.toISOString();
                  if (typeof dateValue === 'string') {
                        const date = new Date(dateValue);
                        return isNaN(date.getTime()) ? new Date().toISOString() : date.toISOString();
                  }
                  return new Date().toISOString();
            }

            loadMockData() {
                  // Mock data for demonstration
                  const mockDonations = [
                        { amount: 25.50, donor: 'John Doe', date: new Date().toISOString(), purpose: 'General Support', category: 'General', transactionId: 'TXN-001' },
                        { amount: 100.00, donor: 'Jane Smith', date: new Date(Date.now() - 86400000).toISOString(), purpose: 'Project Funding', category: 'Projects', transactionId: 'TXN-002' },
                        { amount: 50.00, donor: 'Anonymous', date: new Date(Date.now() - 172800000).toISOString(), purpose: 'General Support', category: 'General', transactionId: 'TXN-003' }
                  ];

                  mockDonations.forEach((donation, index) => {
                        setTimeout(() => {
                              this.addDonation(donation, `mock-${index}`, true);
                        }, index * 1500);
                  });
            }

            addDonation(donation, donationId, isHistorical = false) {
                  const amount = parseFloat(donation.amount) || 0;
                  const coinsCount = Math.floor(amount); // 1 coin = $1
                  
                  // Update stats
                  this.stats.totalDonations++;
                  this.stats.totalAmount += amount;
                  if (donation.donor && donation.donor !== 'Anonymous') {
                        this.stats.donors.add(donation.donor);
                        this.stats.totalDonors = this.stats.donors.size;
                  }
                  
                  this.updateStats();
                  
                  // Batch create coins for better performance
                  const batchSize = 50;
                  const delay = isHistorical ? 0 : 50;
                  
                  for (let batchStart = 0; batchStart < coinsCount; batchStart += batchSize) {
                        setTimeout(() => {
                              const batchEnd = Math.min(batchStart + batchSize, coinsCount);
                              for (let i = batchStart; i < batchEnd; i++) {
                                    this.createCent(donation, donationId, i, coinsCount);
                              }
                              
                              // Update intersection observer for new coins
                              if (this.intersectionObserver) {
                                    for (let i = batchStart; i < batchEnd; i++) {
                                          const cent = this.cents[this.cents.length - (batchEnd - i)];
                                          if (cent && cent.parentNode) {
                                                this.intersectionObserver.observe(cent);
                                          }
                                    }
                              }
                        }, delay * (batchStart / batchSize));
                  }
            }

            getCentFromPool() {
                  // Reuse cent element from pool if available
                  if (this.centPool.length > 0) {
                        const cent = this.centPool.pop();
                        // Ensure it's removed from any previous parent
                        if (cent.parentNode) {
                              cent.parentNode.removeChild(cent);
                        }
                        return cent;
                  }
                  
                  // Create new cent element
                  const cent = document.createElement('div');
                  cent.className = 'cent emoji';
                  cent.textContent = 'ðŸª™';
                  return cent;
            }

            returnCentToPool(cent) {
                  // Clean up and return to pool
                  cent.style.left = '';
                  cent.style.top = '';
                  cent.style.transform = '';
                  cent.removeEventListener('mouseenter', this.showTag);
                  cent.removeEventListener('mouseleave', this.hideTag);
                  cent.removeEventListener('click', this.toggleTag);
                  cent.donationData = null;
                  
                  // Remove physics body from world
                  if (cent.body) {
                        Matter.World.remove(this.world, cent.body);
                        cent.body = null;
                  }
                  
                  this.centPool.push(cent);
            }

            createCent(donation, donationId, index, total) {
                  // Check if we should cluster instead of showing individual coins
                  if (this.cents.length >= this.maxVisibleCents) {
                        if (index === 0) {
                              this.createCentCluster(donation, donationId, total);
                        }
                        return;
                  }
                  
                  const cent = this.getCentFromPool();
                  cent.dataset.donationId = donationId;
                  cent.dataset.index = index;
                  
                  // Store donation data
                  cent.donationData = {
                        donor: donation.donor || 'Anonymous',
                        amount: donation.amount,
                        date: donation.date,
                        purpose: donation.purpose || 'N/A',
                        category: donation.category || 'General',
                        transactionId: donation.transactionId || 'N/A',
                        totalCoins: total
                  };
                  
                  // --- MATTER.JS COIN CREATION ---
                  const { Bodies, World } = Matter;
                  const radius = this.coinSize / 2;
                  
                  // Central drop point at the top of the pool area
                  const startX = this.poolWidth / 2 + (Math.random() - 0.5) * 5; // Slight horizontal randomness
                  const startY = -radius; // Start just above the visible area
                  
                  // Create a circular physics body for the coin
                  const coinBody = Bodies.circle(startX, startY, radius, {
                        restitution: 0.2, // Bounciness
                        friction: 0.8,    // Friction for stacking
                        density: 0.001,   // Weight
                        label: 'coin'
                  });
                  
                  // Attach the body to the DOM element and add to the world
                  cent.body = coinBody;
                  World.add(this.world, coinBody);
                  
                  // Initial DOM positioning (will be updated by the 'afterUpdate' event)
                  cent.style.position = 'absolute';
                  cent.style.width = this.coinSize + 'px';
                  cent.style.height = this.coinSize + 'px';
                  cent.style.left = '0';
                  cent.style.top = '0';
                  cent.style.display = 'flex';
                  cent.style.opacity = '1';
                  cent.style.fontSize = this.coinSize + 'px'; // Adjust emoji size
                  cent.style.lineHeight = this.coinSize + 'px';
                  cent.style.textAlign = 'center';
                  cent.style.justifyContent = 'center';
                  cent.style.alignItems = 'center';
                  cent.style.willChange = 'transform'; // Performance optimization
                  
                  // Ensure cent is in the pool
                  if (!cent.parentNode || cent.parentNode !== this.pool) {
                        if (cent.parentNode) {
                              cent.parentNode.removeChild(cent);
                        }
                        this.pool.appendChild(cent);
                  }
                  
                  // Add hover handlers (only once)
                  if (!cent.hasListeners) {
                        cent.addEventListener('mouseenter', (e) => this.showTag(e, cent));
                        cent.addEventListener('mouseleave', () => this.hideTag(cent));
                        cent.hasListeners = true;
                  }
                  
                  this.cents.push(cent);
                  this.visibleCents.add(cent);
                  
                  // Update search filter if search is active
                  if (this.searchQuery) {
                        this.updateSearchFilter();
                  }
            }

            createCentCluster(donation, donationId, totalCoins) {
                  // Create a cluster representation for large donations
                  const cluster = document.createElement('div');
                  cluster.className = 'cent emoji';
                  cluster.textContent = 'ðŸª™';
                  cluster.style.fontSize = '24px';
                  cluster.style.display = 'flex';
                  cluster.style.alignItems = 'center';
                  cluster.style.justifyContent = 'center';
                  cluster.style.textAlign = 'center';
                  cluster.style.lineHeight = '1';
                  cluster.dataset.donationId = donationId;
                  cluster.dataset.isCluster = 'true';
                  cluster.dataset.count = totalCoins;
                  
                  cluster.donationData = {
                        donor: donation.donor || 'Anonymous',
                        amount: donation.amount,
                        date: donation.date,
                        purpose: donation.purpose || 'N/A',
                        category: donation.category || 'General',
                        transactionId: donation.transactionId || 'N/A',
                        totalCoins: totalCoins,
                        isCluster: true
                  };
                  
                  // Position cluster at bottom
                  const targetX = Math.random() * (this.poolWidth - 40) + 20;
                  const targetY = this.poolHeight - 40;
                  
                  cluster.style.position = 'absolute';
                  cluster.style.left = targetX + 'px';
                  cluster.style.top = targetY + 'px';
                  
                  this.pool.appendChild(cluster);
                  
                  cluster.addEventListener('mouseenter', (e) => this.showTag(e, cluster));
                  cluster.addEventListener('mouseleave', () => this.hideTag(cluster));
                  
                  this.cents.push(cluster);
                  this.visibleCents.add(cluster);
            }


            showTag(event, cent) {
                  if (this.activeTags.has(cent)) return;
                  
                  const tag = document.createElement('div');
                  tag.className = 'donation-tag';
                  
                  const data = cent.donationData;
                  const date = new Date(data.date);
                  const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                  
                  let tagContent = `
                        <div class="tag-header">${data.donor}</div>
                        <div class="tag-item"><strong>Amount:</strong> $${parseFloat(data.amount).toFixed(2)}</div>
                        <div class="tag-item"><strong>Date:</strong> ${formattedDate}</div>
                        <div class="tag-item"><strong>Purpose:</strong> ${data.purpose}</div>
                        <div class="tag-item"><strong>Category:</strong> ${data.category}</div>
                        <div class="tag-item"><strong>Transaction ID:</strong> ${data.transactionId}</div>
                  `;
                  
                  if (data.isCluster && data.totalCoins) {
                        tagContent += `<div class="tag-item"><strong>Coins:</strong> ${data.totalCoins.toLocaleString()} (clustered)</div>`;
                  }
                  
                  tag.innerHTML = tagContent;
                  
                  // Append to pool container so it's inside the box
                  this.pool.appendChild(tag);
                  
                  // Position tag relative to coin, inside the pool container
                  // Get position from Matter.js body if available, otherwise from style
                  let centX, centY;
                  if (cent.body) {
                        centX = cent.body.position.x;
                        centY = cent.body.position.y;
                  } else {
                        centX = parseFloat(cent.style.left) || 0;
                        centY = parseFloat(cent.style.top) || 0;
                  }
                  
                  const tagRect = tag.getBoundingClientRect();
                  
                  // Position to the right or left of the coin, near it
                  let tagX = centX + 25; // Right side of coin
                  let tagY = centY - (tagRect.height / 2) + 10; // Vertically centered on coin
                  
                  // If tag would go outside pool bounds, position to the left instead
                  if (tagX + tagRect.width > this.poolWidth - 20) {
                        tagX = centX - tagRect.width - 25;
                  }
                  
                  // Ensure tag stays within pool bounds
                  if (tagX < 10) tagX = 10;
                  if (tagX + tagRect.width > this.poolWidth - 10) {
                        tagX = this.poolWidth - tagRect.width - 10;
                  }
                  
                  if (tagY < 10) tagY = 10;
                  if (tagY + tagRect.height > this.poolHeight - 10) {
                        tagY = this.poolHeight - tagRect.height - 10;
                  }
                  
                  tag.style.position = 'absolute';
                  tag.style.left = tagX + 'px';
                  tag.style.top = tagY + 'px';
                  tag.style.zIndex = '1000';
                  
                  // Use requestAnimationFrame for smooth appearance
                  requestAnimationFrame(() => {
                        tag.classList.add('visible');
                  });
                  
                  this.activeTags.set(cent, tag);
            }

            hideTag(cent) {
                  const tag = this.activeTags.get(cent);
                  if (tag) {
                        tag.classList.remove('visible');
                        setTimeout(() => {
                              if (tag.parentNode) {
                                    tag.parentNode.removeChild(tag);
                              }
                              this.activeTags.delete(cent);
                        }, 200);
                  }
            }

            updateStats() {
                  const totalDonationsEl = document.getElementById('totalDonations');
                  const totalAmountEl = document.getElementById('totalAmount');
                  const totalDonorsEl = document.getElementById('totalDonors');
                  
                  if (totalDonationsEl) {
                        this.animateValue(totalDonationsEl, this.stats.totalDonations, (val) => Math.floor(val).toLocaleString());
                  }
                  if (totalAmountEl) {
                        this.animateValue(totalAmountEl, this.stats.totalAmount, (val) => '$' + val.toFixed(2));
                  }
                  if (totalDonorsEl) {
                        this.animateValue(totalDonorsEl, this.stats.totalDonors, (val) => Math.floor(val).toLocaleString());
                  }
            }

            animateValue(element, target, formatter) {
                  const start = parseFloat(element.textContent.replace(/[^0-9.]/g, '')) || 0;
                  const duration = 1000;
                  const startTime = performance.now();
                  
                  const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const ease = 1 - Math.pow(1 - progress, 3);
                        const current = start + (target - start) * ease;
                        element.textContent = formatter(current);
                        
                        if (progress < 1) {
                              requestAnimationFrame(animate);
                        } else {
                              element.textContent = formatter(target);
                        }
                  };
                  
                  requestAnimationFrame(animate);
            }


            destroy() {
                  if (this.runner) {
                        Runner.stop(this.runner);
                  }
                  if (this.engine) {
                        Engine.clear(this.engine);
                  }
                  if (this.airtablePollInterval) {
                        clearInterval(this.airtablePollInterval);
                  }
                  // Clean up all cents and their physics bodies
                  this.cents.forEach(cent => {
                        if (cent.body) {
                              Matter.World.remove(this.world, cent.body);
                        }
                        if (cent.parentNode) {
                              cent.parentNode.removeChild(cent);
                        }
                  });
                  this.cents = [];
                  this.visibleCents.clear();
                  this.activeTags.clear();
            }
      }

      // Initialize donation pool when DOM is ready
      let donationPool;
      function initDonationPool() {
            const poolContainer = document.getElementById('donationPool');
            if (poolContainer) {
                  donationPool = new DonationPool(poolContainer);
            } else {
                  // Retry if container not ready yet
                  setTimeout(initDonationPool, 100);
            }
      }
      
      if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDonationPool);
      } else {
            initDonationPool();
      }

      // Stoplight menu functionality
      const stoplight = document.getElementById('stoplight');
      const dropdownMenu = document.getElementById('dropdown-menu');
      let isMenuOpen = false;

      function toggleMenu() {
        isMenuOpen = !isMenuOpen;
        stoplight.classList.toggle('active', isMenuOpen);
        dropdownMenu.classList.toggle('active', isMenuOpen);
      }

      stoplight.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleMenu();
      });

      document.addEventListener('click', (e) => {
        if (!stoplight.contains(e.target) && !dropdownMenu.contains(e.target) && isMenuOpen) {
          toggleMenu();
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isMenuOpen) {
          toggleMenu();
        }
      });

      dropdownMenu.addEventListener('click', (e) => {
        e.stopPropagation();
      });
      
      // Action buttons
      const downloadButton = document.getElementById('downloadButton');
      const challengeButton = document.getElementById('challengeButton');
      const challengeModal = document.getElementById('challengeModal');
      const closeModal = document.getElementById('closeModal');
      
      downloadButton.addEventListener('click', () => {
            alert('Database download will be available upon funding launch.');
      });
      
      challengeButton.addEventListener('click', (e) => {
            e.stopPropagation();
            challengeModal.classList.toggle('active');
      });
      
      closeModal.addEventListener('click', () => {
            challengeModal.classList.remove('active');
      });
      
      document.addEventListener('click', (e) => {
            if (!challengeModal.contains(e.target) && !challengeButton.contains(e.target)) {
                  challengeModal.classList.remove('active');
            }
      });
      
      document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && challengeModal.classList.contains('active')) {
                  challengeModal.classList.remove('active');
            }
      });
      
      // Section animation on scroll
      const sections = document.querySelectorAll('.database-section, .action-section');
      const observerOptions = {
            threshold: 0.1
      };
      
      const sectionObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach((entry, index) => {
                  if (entry.isIntersecting) {
                        setTimeout(() => {
                              entry.target.classList.add('visible');
                        }, index * 100);
                        observer.unobserve(entry.target);
                  }
            });
      }, observerOptions);
      
      sections.forEach(section => sectionObserver.observe(section));
  </script>
</body>
</html>
